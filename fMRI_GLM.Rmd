---
title: "fMRI"
date: "`r format(Sys.time(), '%d/%m/%Y')`"
author: "Ludovica Nucci (Start 23/03/2020; language: it)"
output: 
  html_document: 
    fig_height: 7
    fig_width: 10
    highlight: tango
    theme: cerulean
    toc: true
editor_options: 
  chunk_output_type: console
---

#Dati

```{r preamble, message=FALSE, warning=FALSE}
library(rstudioapi)
cat("\f")
rm(list=ls())
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path )); print(getwd())

library(oro.nifti)
```

```{r sub_100206}
nii = readNIfTI("./tfMRI_MOTOR_LR/tfMRI_MOTOR_LR_100206.nii")
ar = array(c(nii), c(902629, 284))
x = rep(1:91,109*91)
y = rep(rep(1:109, length.out=91*109, each=91),91)
z = rep(1:91, length.out=91*109*91, each=91*109)
ar = cbind(x,y,z,ar)
ar=t(ar)
ar = as.data.frame(ar)
index = which(colMeans(ar[-c(1,2,3),])!=0)
ar = ar[,index]

ar_100206 = ar
rm(ar)
save(ar_100206, file = "./tfMRI_MOTOR_LR/sub_100206.RData")
```

#Attivazioni dei voxel secondo il modello standard (GLM)

```{r preamble, message=FALSE, warning=FALSE}
library(rstudioapi)
cat("\f")
rm(list=ls())
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path )); print(getwd())

library(fmri)
library(oro.nifti)
```

```{r sub_100206}
lf=read.table("./tfMRI_MOTOR_LR/lf_100206.txt", sep="\t") 
rf=read.table("./tfMRI_MOTOR_LR/rf_100206.txt", sep="\t")
rh=read.table("./tfMRI_MOTOR_LR/rh_100206.txt", sep="\t")
lh=read.table("./tfMRI_MOTOR_LR/lh_100206.txt", sep="\t")
t=read.table("./tfMRI_MOTOR_LR/t_100206.txt", sep="\t")

#Tempo di inizio e durata degli stimoli (in numero di scan) -> abbiamo 5 diversi stimoli
onsets_lf=c(ceiling(lf[1,1]/0.72), ceiling(lf[2,1]/0.72))
onsets_rf=c(ceiling(rf[1,1]/0.72), ceiling(rf[2,1]/0.72))
onsets_rh=c(ceiling(rh[1,1]/0.72), ceiling(rh[2,1]/0.72))
onsets_lh=c(ceiling(lh[1,1]/0.72), ceiling(lh[2,1]/0.72))
onsets_t=c(ceiling(t[1,1]/0.72), ceiling(t[2,1]/0.72))
dur=c(16,16)

#Risposta attesa per ciascuno stimolo
hrf_lf=fmri.stimulus(scans = 284,  onsets=onsets_lf, durations = dur)
hrf_rf=fmri.stimulus(scans = 284,  onsets=onsets_rf, durations = dur)
hrf_rh=fmri.stimulus(scans = 284,  onsets=onsets_rh, durations = dur)
hrf_lh=fmri.stimulus(scans = 284,  onsets=onsets_lh, durations = dur)
hrf_t=fmri.stimulus(scans = 284,  onsets=onsets_t, durations = dur)

#design matrix 
x=fmri.design(cbind(hrf_lf, hrf_rf , hrf_rh , hrf_lh , hrf_t), order = 2)

load("~/TESI/tfMRI_MOTOR_LR/sub_100206.RData")
dataMatrix=ar_100206[-c(1,2,3),1:115000]
#la matrice dataMatrix contiene per colonna le serie temporali relative ai primi 115000 voxel del soggetto 100206

#Regressione lineare con fattori in ingresso = design matrix, fattore in uscita = serie temporale di ciascun voxel 
lms=apply(dataMatrix, 2, function(y) lm(y~ 0+ x))
summaries1=lapply(lms, summary)
save(summaries1, file = "./tfMRI_MOTOR_LR/summaries1.RData")

dataMatrix=ar_100206[-c(1,2,3),115001:230307]
lms=apply(dataMatrix, 2, function(y) lm(y~ 0+ x))
summaries2=lapply(lms, summary)
save(summaries2, file = "./tfMRI_MOTOR_LR/summaries2.RData")
```

```{r template brain}
nii = readNIfTI("./tfMRI_MOTOR_LR/tfMRI_MOTOR_LR_100206.nii")
nii_1=nii[,,,1]
save(nii_1, file = "./tfMRI_MOTOR_LR/nii_1.RData")
#TROVARE UN ATLANTE?
```

```{r sub_100206}
load("~/TESI/tfMRI_MOTOR_LR/summaries1.RData")
load("~/TESI/tfMRI_MOTOR_LR/summaries2.RData")
load("~/TESI/tfMRI_MOTOR_LR/sub_100206.RData")
coefs1=lapply(summaries1, function(x) x$coefficients)
coefs2=lapply(summaries2, function(x) x$coefficients)

#lf
lf_vals1=lapply( coefs1, function(x) x[1,])
lf_est1=lapply( lf_vals1, function(x) x[1])
lf_pvals1=lapply( lf_vals1, function(x) x[4])
lf_act1=which(lf_pvals1<0.001)

lf_vals2=lapply( coefs2, function(x) x[1,])
lf_est2=lapply( lf_vals2, function(x) x[1])
lf_pvals2=lapply( lf_vals2, function(x) x[4])
lf_act2=which(lf_pvals2<0.001) 
lf_act2=lf_act2 + 115000 
#sommo 115000 perchè i coefficienti sono relativi ai voxel dal 115001 in poi

lf_act=c(lf_act1, lf_act2) 
#sono le colonne della matrice ar_100206 corrispondenti ai voxel che si sono attivati in risposta a lf

#Rappresentazione grafica delle attivazioni su un cervello
load("~/TESI/tfMRI_MOTOR_LR/nii_1.RData")
nii_lf=nii_1

lf_ar=t(ar_100206[1:3,-lf_act]) 
#sono le coordinate x, y, z nell'array 4D dei voxel che NON si sono attivati in risposta a lf 
nii_lf[lf_ar]=0
#usiamo come sfondo l'immagine del cervello ad un tempo fissato (il tempo 1) in scala di grigi ed a questa sovrapponiamo la stessa immagine, in cui ai voxel non attivati assegnamo valore NA, a colori
overlay(nii_1, nii_lf, NA.y=TRUE)
overlay(nii_1, nii_lf, plane="coronal", NA.y=TRUE)

#rf
rf_vals1=lapply( coefs1, function(x) x[2,])
rf_est1=lapply( rf_vals1, function(x) x[1])
rf_pvals1=lapply( rf_vals1, function(x) x[4])
rf_act1=which(rf_pvals1<0.001)

rf_vals2=lapply( coefs2, function(x) x[2,])
rf_est2=lapply( rf_vals2, function(x) x[1])
rf_pvals2=lapply( rf_vals2, function(x) x[4])
rf_act2=which(rf_pvals2<0.001) 
rf_act2=rf_act2 + 115000 
#sommo 115000 perchè i coefficienti sono relativi ai voxel dal 115001 in poi

rf_act=c(rf_act1, rf_act2) 
#sono le colonne della matrice ar_100206 corrispondenti ai voxel che si sono attivati in risposta a rf

#Rappresentazione grafica delle attivazioni su un cervello
nii_rf=nii_1

rf_ar=t(ar_100206[1:3,-rf_act]) 
#sono le coordinate x, y, z nell'array 4D dei voxel che NON si sono attivati in risposta a rf 
nii_rf[rf_ar]=0
#usiamo come sfondo l'immagine del cervello ad un tempo fissato (il tempo 1) in scala di grigi ed a questa sovrapponiamo la stessa immagine, in cui ai voxel non attivati assegnamo valore NA, a colori 
overlay(nii_1, nii_rf, NA.y=TRUE)
overlay(nii_1, nii_rf, plane="coronal", NA.y=TRUE)

#rh
rh_vals1=lapply( coefs1, function(x) x[3,])
rh_est1=lapply( rh_vals1, function(x) x[1])
rh_pvals1=lapply( rh_vals1, function(x) x[4])
rh_act1=which(rh_pvals1<0.001)

rh_vals2=lapply( coefs2, function(x) x[3,])
rh_est2=lapply( rh_vals2, function(x) x[1])
rh_pvals2=lapply( rh_vals2, function(x) x[4])
rh_act2=which(rh_pvals2<0.001) 
rh_act2=rh_act2 + 115000 
#sommo 115000 perchè i coefficienti sono relativi ai voxel dal 115001 in poi

rh_act=c(rh_act1, rh_act2) 
#sono le colonne della matrice ar_100206 corrispondenti ai voxel che si sono attivati  in risposta a rh

#Rappresentazione grafica delle attivazioni su un cervello
nii_rh=nii_1

rh_ar=t(ar_100206[1:3,-rh_act]) 
#sono le coordinate x, y, z nell'array 4D dei voxel che NON si sono attivati in risposta a rh
nii_rh[rh_ar]=0
#usiamo come sfondo l'immagine del cervello ad un tempo fissato (il tempo 1) in scala di grigi ed a questa sovrapponiamo la stessa immagine, in cui ai voxel non attivati assegnamo valore NA, a colori 
overlay(nii_1, nii_rh, NA.y=TRUE)
overlay(nii_1, nii_rh, plane="coronal", NA.y=TRUE)

#lh
lh_vals1=lapply( coefs1, function(x) x[4,])
lh_est1=lapply( lh_vals1, function(x) x[1])
lh_pvals1=lapply( lh_vals1, function(x) x[4])
lh_act1=which(lh_pvals1<0.001)

lh_vals2=lapply( coefs2, function(x) x[4,])
lh_est2=lapply( lh_vals2, function(x) x[1])
lh_pvals2=lapply( lh_vals2, function(x) x[4])
lh_act2=which(lh_pvals2<0.001) 
lh_act2=lh_act2 + 115000 
#sommo 115000 perchè i coefficienti sono relativi ai voxel dal 115001 in poi

lh_act=c(lh_act1, lh_act2) 
#sono le colonne della matrice ar_100206 corrispondenti ai voxel che si sono attivati in risposta a lh

#Rappresentazione grafica delle attivazioni su un cervello
nii_lh=nii_1

lh_ar=t(ar_100206[1:3,-lh_act]) 
#sono le coordinate x, y, z nell'array 4D dei voxel che NON si sono attivati in risposta a lh
nii_lh[lh_ar]=0
#usiamo come sfondo l'immagine del cervello ad un tempo fissato (il tempo 1) in scala di grigi ed a questa sovrapponiamo la stessa immagine, in cui ai voxel non attivati assegnamo valore NA, a colori 
overlay(nii_1, nii_lh, NA.y=TRUE)
overlay(nii_1, nii_lh, plane="coronal", NA.y=TRUE)

#t
t_vals1=lapply( coefs1, function(x) x[5,])
t_est1=lapply( t_vals1, function(x) x[1])
t_pvals1=lapply( t_vals1, function(x) x[4])
t_act1=which(t_pvals1<0.001)

t_vals2=lapply( coefs2, function(x) x[5,])
t_est2=lapply( t_vals2, function(x) x[1])
t_pvals2=lapply( t_vals2, function(x) x[4])
t_act2=which(t_pvals2<0.001) 
t_act2=t_act2 + 115000 
#sommo 115000 perchè i coefficienti sono relativi ai voxel dal 115001 in poi

t_act=c(t_act1, t_act2) 
#sono le colonne della matrice ar_100206 corrispondenti ai voxel che si sono attivati in risposta a t

#Rappresentazione grafica delle attivazioni su un cervello
nii_t=nii_1

t_ar=t(ar_100206[1:3,-t_act]) 
#sono le coordinate x, y, z nell'array 4D dei voxel che NON si sono attivati in risposta a t
nii_t[t_ar]=0
#usiamo come sfondo l'immagine del cervello ad un tempo fissato (il tempo 1) in scala di grigi ed a questa sovrapponiamo la stessa immagine, in cui ai voxel non attivati assegnamo valore NA, a colori
overlay(nii_1, nii_t, NA.y=TRUE)
overlay(nii_1, nii_t, plane="coronal", NA.y=TRUE)
```

